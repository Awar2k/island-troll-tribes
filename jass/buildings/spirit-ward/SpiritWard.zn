library SpiritWard requires ID, Table, PublicLibrary, Ascii {
  Table wardTable;

  function isWardReviving(unit u) -> boolean {
    return wardTable.unit[GetHandleId(u)] != null;
  }

  function setWardStartedReviving(unit u, unit h) {
    wardTable.unit[GetHandleId(u)] = h;
    wardTable.unit[GetHandleId(h)] = u;
  }

  function setWardStoppedReviving(unit u) {
    integer wardId = GetHandleId(u);
    integer heroId = GetHandleId(wardTable.unit[wardId]);
    wardTable.remove(heroId);
    wardTable.remove(wardId);
  }

	function onPlayerLeave() {
    group g = GetUnitsOfPlayerAndTypeId(GetTriggerPlayer(), UNIT_SPIRIT_WARD);
    unit u = GetPlayerTroll(GetTriggerPlayer());
    force f = GetPlayerTribe(GetTriggerPlayer());
    unit d;

    if (CountUnitsInGroup(g) >= 1) {
      d = FirstOfGroup(g);
      while (d != null) {
        SetUnitOwner(d, ForcePickRandomPlayer(f), false);
        GroupRemoveUnit(g, d);
        d = FirstOfGroup(g);
      }
    }

    DestroyGroup(g);

    g = null;
    f = null;
    u = null;
    d = null;
	}

  function onPlayerSelectWard() {
    if (GetUnitTypeId(GetTriggerUnit()) == UNIT_SPIRIT_WARD &&
        IsUnitAlly(GetTriggerUnit(), GetTriggerPlayer()) &&
        !isWardReviving(GetTriggerUnit())) {
      debug BJDebugMsg("Ward select will change owner!");
      SetUnitOwner(GetTriggerUnit(), GetTriggerPlayer(), false);
    }
  }

  function onReviveStart() {
    group selected = CreateGroup();
    unit ward;
    unit hero = GetTriggerUnit();

    // debug BJDebugMsg("Ward started reviving");

    GroupEnumUnitsSelected(selected, GetOwningPlayer(hero), Condition(function FilterUnitIsSpiritWard));
    ward = FirstOfGroup(selected);
    if (ward != null) {
      debug BJDebugMsg("Ward started reviving success!");
      setWardStartedReviving(ward, hero);
    }

    DestroyGroup(selected);

    selected = null;
    ward = null;
    hero = null;
  }

  function onReviveCancel() {
    unit ward = wardTable.unit[GetHandleId(GetTriggerUnit())];
    debug BJDebugMsg("Ward cancelled reviving");
    setWardStoppedReviving(ward);
    ward = null;
  }

  function onReviveFinish() {
    unit hero = GetTriggerUnit();
    unit ward = wardTable.unit[GetHandleId(hero)];
    integer handleId = GetHandleId(ward);

    SetPlayerState(GetOwningPlayer(hero), PLAYER_STATE_RESOURCE_GOLD, udg_MAX_HEAT);

    if (ward != null) {
      TimerStart(NewTimerEx(handleId), 0, false, function() {
        integer handleId = GetTimerData(GetExpiredTimer());
        unit ward = wardTable.unit[handleId];
        ReleaseTimer(GetExpiredTimer());
        SetWidgetLife(ward, 0);
        setWardStoppedReviving(ward);
        ward = null;
      });
    }

    hero = null;
    ward = null;
  }

	function onInit() {
		trigger leaveTrigger = CreateTrigger();
    trigger selectWardTrigger = CreateTrigger();
    trigger reviveStartTrigger = CreateTrigger();
    trigger reviveCancelTrigger = CreateTrigger();
    trigger reviveFinishTrigger = CreateTrigger();
		integer i;

    wardTable = Table.create();

		for (0 <= i < 12) {
      TriggerRegisterPlayerEventLeave(leaveTrigger, Player(i));
      TriggerRegisterPlayerUnitEvent(selectWardTrigger, Player(i), EVENT_PLAYER_UNIT_SELECTED, null);
      TriggerRegisterPlayerUnitEvent(reviveStartTrigger, Player(i), EVENT_PLAYER_HERO_REVIVE_START, null);
      TriggerRegisterPlayerUnitEvent(reviveCancelTrigger, Player(i), EVENT_PLAYER_HERO_REVIVE_CANCEL, null);
      TriggerRegisterPlayerUnitEvent(reviveFinishTrigger, Player(i), EVENT_PLAYER_HERO_REVIVE_FINISH, null);
		}

    TriggerAddAction(leaveTrigger, function onPlayerLeave);
    TriggerAddAction(selectWardTrigger, function onPlayerSelectWard);
    TriggerAddAction(reviveStartTrigger, function onReviveStart);
    TriggerAddAction(reviveCancelTrigger, function onReviveCancel);
    TriggerAddAction(reviveFinishTrigger, function onReviveFinish);

    leaveTrigger = null;
    selectWardTrigger = null;
    reviveStartTrigger = null;
    reviveCancelTrigger = null;
    reviveFinishTrigger = null;
	}
}
