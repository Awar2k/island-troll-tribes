
library TradeShipStop requires PublicLibrary {

  public struct TradeShipStop {
    private static region tradeStops;

    private rect stopAt;
    private thistype nextStop;
    private thistype forkTo;
    private real forkProbability;

    static method create( rect s ) -> thistype {
      thistype self = thistype.allocate();
      self.stopAt = s;
      self.nextStop = -1;
      self.forkTo = -1;
      self.forkProbability = 0;
      RegionAddRect(tradeStops, s);
      return self;
    }

    public static method onInit() {
      tradeStops = CreateRegion();
    }

    public static method getTradeRegion() -> region {
      return tradeStops;
    }

    method containsShip(unit ship) -> boolean {
      return IsWidgetInRect( stopAt, ship );
    }

    method operator next() -> thistype {
      if ( forkTo < 0 || GetRandomReal(0, 1) > forkProbability ) {
        return nextStop;
      } else {
        return forkTo;
      }
    }

    method addStop( rect r ) -> thistype {
      if ( nextStop >= 0 ) {
        return nextStop.addStop( r );
      } else {
        nextStop = thistype.create( r );
        return nextStop;
      }
    }

    method addTradeShipStop( thistype next ) -> thistype {
      nextStop = next;
      return this;
    }

    method tail() -> thistype {
      if ( nextStop >= 0 ) {
        return nextStop.tail();
      } else {
        return this;
      }
    }

    /*
      we can only add one fork
    */
    method addFork( thistype fork, real probability ) -> thistype {
      if ( forkTo < 0 ) {
        forkTo = fork;
        forkProbability = probability;
      } else {
        debug BJDebugMsg( "Attempting to add multiple forks to " + I2S( this ) );
      }
      return this;
    }

    method isEndOfRoute() -> boolean {
      return nextStop == -1;
    }

    method operator x() -> real {
      return GetRectCenterX( stopAt );
    }

    method operator y() -> real {
      return GetRectCenterY( stopAt );
    }

    method clone() -> thistype {
      thistype copy = thistype.create(stopAt);
      copy.nextStop = nextStop;
      copy.forkTo = forkTo;
      return copy;
    }

    method reverse() -> thistype {
      thistype head = this;
      thistype next;

      if (nextStop >= 0) {
        next = nextStop.clone();
        head = next.reverse();
        next.nextStop = this;
      }

      nextStop = -1;
      forkTo = -1;

      return head;
    }
  }
}

